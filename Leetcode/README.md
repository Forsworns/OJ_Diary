### 1. Two Sum

- 一个方法是使用一个数组维护快排时发生调换的位置。$O(nlog(n))$。

- 另一个建哈希表记录读入的数据及位置，注意两个数字相同的情况只有一种，同时map的特性决定了只会插入第一个，第二次用`insert()`时就不会再插入。所以在遍历时第二次出现时再读取第一个在哪里就行。$O(n)$。

### 2. Add Two Numbers 

- 链表注意没有head项，所以用自身是否NULL判断循环条件，有head则用next。注意进位。
- 还有一个点是大数，用链表存储时采用的是反向顺序存储数字的方法，这样便于进位操作（这里题目直接告了）

### 3. Longest Substring Without Repeating Characters

- 暴力显然不可取，$O(n^4)$超时
- 类似最长递增子序列思路，选用集合记录当前读取到的字符（C++STL中的set是采用红黑树实现的，unordered_set是哈希实现）
- 直接正反遍历$O(2n)$已经可以消除很多问题，但是例如”ohomm“仍然存在，最后选择了回到重复的字母之后位置。有一些时间比较早的速度记录是当时还没有给这样的特例，不必参考。

###  4. Median of Two Sorted Arrays*

- 两个有序的数列，并且提示了$O(log(m+n))$，容易想到采用二分查找的思路。

### 5.  Longest Palindromic Substring

- 经典的最长回文子串问题，采用动态规划的方法，用$(i,j)$记录从$i$到$j$是不是回文串。初始化时需要先单个和两个字符的情况，总的时间复杂度为打表的复杂度$O(n^2)$

### 6. ZigZag Conversion

- 直接利用余数找规律，两部分，针对$(2r-2)$和$(r-1)$求两次余数。接下来用几个vector采用类似哈希的思路保存zig形式的每一行，接着再遍历一次vector的数组，读出zig形式。注意特例只有一行的情况。总的复杂度$O(n)$

### 7. Inverse Integer

- 输入是32位的